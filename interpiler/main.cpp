// 
// Interpiler - turn an interpreter into a compiler
// Copyright (C) 2015  FÃ©lix Cloutier
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
// 

#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/Module.h>
#include <llvm/IRReader/IRReader.h>
#include <llvm/Support/CommandLine.h>
#include <llvm/Support/FileSystem.h>
#include <llvm/Support/raw_ostream.h>
#include <llvm/Support/SourceMgr.h>

#include <iostream>
#include <memory>
#include <string>
#include <vector>

#include "synthesized_class.h"

using namespace llvm;
using namespace std;

synthesized_class interpile(LLVMContext& context, unique_ptr<Module> module, const string& class_name);

namespace args
{
	cl::opt<string> module_file(cl::Positional, cl::Required, cl::desc("<input module>"));
	cl::opt<string> class_name("c", cl::desc("Output class name (defaults to module name)"), cl::value_desc("classname"));
	cl::opt<string> of_name("o", cl::desc("Output files name (defaults to <classname>)"), cl::value_desc("filename"));
	cl::opt<string> of_header_name("oh", cl::desc("Output header file name (defaults to <filename>.h)"), cl::value_desc("header.h"));
	cl::opt<string> of_impl_name("oi", cl::desc("Output implementation file name (defaults to <filename>.cpp)"), cl::value_desc("impl.cpp"));
}

namespace
{
	string file_name(const string& file)
	{
		string::const_iterator nameStart = file.begin();
		for (auto iter = nameStart; iter != file.end(); iter++)
		{
			if (*iter == '/')
			{
				nameStart = iter + 1;
			}
		}
		return string(nameStart, file.end());
	}
	
	string remove_extension(const string& file)
	{
		size_t endIndex = file.find_last_of('.');
		return file.substr(0, endIndex);
	}
	
	template<size_t N>
	void include(raw_ostream& ostream, const char (&quotes)[N], const string& file)
	{
		static_assert(N >= 2, "Need at least two characters in quotes array");
		ostream << "#include " << quotes[0] << file << quotes[1] << '\n';
	}

	void include_u(raw_ostream& ostream, const string& file)
	{
		include(ostream, "\"\"", file);
	}
	
	void include_s(raw_ostream& ostream, const string& file)
	{
		include(ostream, "<>", file);
	}
}

int main(int argc, const char * argv[])
{
	LLVMContext context;
	cl::ParseCommandLineOptions(argc, argv);
	
	SMDiagnostic error;
	if (unique_ptr<Module> module = parseIRFile(args::module_file, error, context))
	{
		if (args::class_name == "")
		{
			args::class_name = remove_extension(file_name(args::module_file));
		}
		
		if (args::of_name == "")
		{
			args::of_name = static_cast<string&>(args::class_name);
		}
		
		if (args::of_header_name == "")
		{
			args::of_header_name = args::of_name + ".h";
		}
		
		if (args::of_impl_name == "")
		{
			args::of_impl_name = args::of_name + ".cpp";
		}
		
		error_code error;
		raw_fd_ostream header(args::of_header_name, error, sys::fs::F_None);
		if (error)
		{
			cerr << file_name(argv[0]) << ": can't open header output file" << endl;
			return 1;
		}
		else
		{
			raw_fd_ostream impl(args::of_impl_name, error, sys::fs::F_None);
			if (error)
			{
				cerr << file_name(argv[0]) << ": can't open implementation output file" << endl;
				return 1;
			}
			else
			{
				auto klass = interpile(context, move(module), args::class_name);
				header << "// file autogenerated by interpiler\n";
				include_s(header, "llvm/IR/DerivedTypes.h");
				include_s(header, "llvm/IR/IRBuilder.h");
				include_s(header, "llvm/IR/LLVMContext.h");
				include_s(header, "llvm/IR/Module.h");
				include_s(header, "unordered_map");
				include_s(header, "string");
				include_s(header, "vector");
				header << '\n';
				klass.print_declaration(header);
				
				impl << "// file autogenerated by interpiler\n";
				include_s(impl, "llvm/IR/Constants.h");
				include_u(impl, args::of_header_name);
				impl << '\n';
				klass.print_definition(impl);
			}
		}
	}
	else
	{
		cerr << file_name(argv[0]) << ": " << error.getMessage().str() << endl;
		return 1;
	}
}
